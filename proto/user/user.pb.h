// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/user/user.proto

#ifndef PROTOBUF_INCLUDED_proto_2fuser_2fuser_2eproto
#define PROTOBUF_INCLUDED_proto_2fuser_2fuser_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fuser_2fuser_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fuser_2fuser_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_proto_2fuser_2fuser_2eproto();
namespace erogen {
class ChangeEmailRequest;
class ChangeEmailRequestDefaultTypeInternal;
extern ChangeEmailRequestDefaultTypeInternal _ChangeEmailRequest_default_instance_;
class ChangeEmailResponse;
class ChangeEmailResponseDefaultTypeInternal;
extern ChangeEmailResponseDefaultTypeInternal _ChangeEmailResponse_default_instance_;
class ChangePasswordRequest;
class ChangePasswordRequestDefaultTypeInternal;
extern ChangePasswordRequestDefaultTypeInternal _ChangePasswordRequest_default_instance_;
class ChangePasswordResponse;
class ChangePasswordResponseDefaultTypeInternal;
extern ChangePasswordResponseDefaultTypeInternal _ChangePasswordResponse_default_instance_;
class ChangeUsernameRequest;
class ChangeUsernameRequestDefaultTypeInternal;
extern ChangeUsernameRequestDefaultTypeInternal _ChangeUsernameRequest_default_instance_;
class ChangeUsernameResponse;
class ChangeUsernameResponseDefaultTypeInternal;
extern ChangeUsernameResponseDefaultTypeInternal _ChangeUsernameResponse_default_instance_;
class DeleteRequest;
class DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
class DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class ForgotPasswordRequest;
class ForgotPasswordRequestDefaultTypeInternal;
extern ForgotPasswordRequestDefaultTypeInternal _ForgotPasswordRequest_default_instance_;
class ForgotPasswordResponse;
class ForgotPasswordResponseDefaultTypeInternal;
extern ForgotPasswordResponseDefaultTypeInternal _ForgotPasswordResponse_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
class LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class LoginResponse_TokenPayload;
class LoginResponse_TokenPayloadDefaultTypeInternal;
extern LoginResponse_TokenPayloadDefaultTypeInternal _LoginResponse_TokenPayload_default_instance_;
class RegisterRequest;
class RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
class RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class ResetPasswordRequest;
class ResetPasswordRequestDefaultTypeInternal;
extern ResetPasswordRequestDefaultTypeInternal _ResetPasswordRequest_default_instance_;
class ResetPasswordResponse;
class ResetPasswordResponseDefaultTypeInternal;
extern ResetPasswordResponseDefaultTypeInternal _ResetPasswordResponse_default_instance_;
class UpdateRequest;
class UpdateRequestDefaultTypeInternal;
extern UpdateRequestDefaultTypeInternal _UpdateRequest_default_instance_;
class UpdateResponse;
class UpdateResponseDefaultTypeInternal;
extern UpdateResponseDefaultTypeInternal _UpdateResponse_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserRequest;
class UserRequestDefaultTypeInternal;
extern UserRequestDefaultTypeInternal _UserRequest_default_instance_;
class UserResponse;
class UserResponseDefaultTypeInternal;
extern UserResponseDefaultTypeInternal _UserResponse_default_instance_;
class UsersRequest;
class UsersRequestDefaultTypeInternal;
extern UsersRequestDefaultTypeInternal _UsersRequest_default_instance_;
class ValidateTokenRequest;
class ValidateTokenRequestDefaultTypeInternal;
extern ValidateTokenRequestDefaultTypeInternal _ValidateTokenRequest_default_instance_;
class ValidateTokenResponse;
class ValidateTokenResponseDefaultTypeInternal;
extern ValidateTokenResponseDefaultTypeInternal _ValidateTokenResponse_default_instance_;
class VerifySecurityQARequest;
class VerifySecurityQARequestDefaultTypeInternal;
extern VerifySecurityQARequestDefaultTypeInternal _VerifySecurityQARequest_default_instance_;
class VerifySecurityQAResponse;
class VerifySecurityQAResponseDefaultTypeInternal;
extern VerifySecurityQAResponseDefaultTypeInternal _VerifySecurityQAResponse_default_instance_;
}  // namespace erogen
namespace google {
namespace protobuf {
template<> ::erogen::ChangeEmailRequest* Arena::CreateMaybeMessage<::erogen::ChangeEmailRequest>(Arena*);
template<> ::erogen::ChangeEmailResponse* Arena::CreateMaybeMessage<::erogen::ChangeEmailResponse>(Arena*);
template<> ::erogen::ChangePasswordRequest* Arena::CreateMaybeMessage<::erogen::ChangePasswordRequest>(Arena*);
template<> ::erogen::ChangePasswordResponse* Arena::CreateMaybeMessage<::erogen::ChangePasswordResponse>(Arena*);
template<> ::erogen::ChangeUsernameRequest* Arena::CreateMaybeMessage<::erogen::ChangeUsernameRequest>(Arena*);
template<> ::erogen::ChangeUsernameResponse* Arena::CreateMaybeMessage<::erogen::ChangeUsernameResponse>(Arena*);
template<> ::erogen::DeleteRequest* Arena::CreateMaybeMessage<::erogen::DeleteRequest>(Arena*);
template<> ::erogen::DeleteResponse* Arena::CreateMaybeMessage<::erogen::DeleteResponse>(Arena*);
template<> ::erogen::ForgotPasswordRequest* Arena::CreateMaybeMessage<::erogen::ForgotPasswordRequest>(Arena*);
template<> ::erogen::ForgotPasswordResponse* Arena::CreateMaybeMessage<::erogen::ForgotPasswordResponse>(Arena*);
template<> ::erogen::LoginRequest* Arena::CreateMaybeMessage<::erogen::LoginRequest>(Arena*);
template<> ::erogen::LoginResponse* Arena::CreateMaybeMessage<::erogen::LoginResponse>(Arena*);
template<> ::erogen::LoginResponse_TokenPayload* Arena::CreateMaybeMessage<::erogen::LoginResponse_TokenPayload>(Arena*);
template<> ::erogen::RegisterRequest* Arena::CreateMaybeMessage<::erogen::RegisterRequest>(Arena*);
template<> ::erogen::RegisterResponse* Arena::CreateMaybeMessage<::erogen::RegisterResponse>(Arena*);
template<> ::erogen::ResetPasswordRequest* Arena::CreateMaybeMessage<::erogen::ResetPasswordRequest>(Arena*);
template<> ::erogen::ResetPasswordResponse* Arena::CreateMaybeMessage<::erogen::ResetPasswordResponse>(Arena*);
template<> ::erogen::UpdateRequest* Arena::CreateMaybeMessage<::erogen::UpdateRequest>(Arena*);
template<> ::erogen::UpdateResponse* Arena::CreateMaybeMessage<::erogen::UpdateResponse>(Arena*);
template<> ::erogen::User* Arena::CreateMaybeMessage<::erogen::User>(Arena*);
template<> ::erogen::UserRequest* Arena::CreateMaybeMessage<::erogen::UserRequest>(Arena*);
template<> ::erogen::UserResponse* Arena::CreateMaybeMessage<::erogen::UserResponse>(Arena*);
template<> ::erogen::UsersRequest* Arena::CreateMaybeMessage<::erogen::UsersRequest>(Arena*);
template<> ::erogen::ValidateTokenRequest* Arena::CreateMaybeMessage<::erogen::ValidateTokenRequest>(Arena*);
template<> ::erogen::ValidateTokenResponse* Arena::CreateMaybeMessage<::erogen::ValidateTokenResponse>(Arena*);
template<> ::erogen::VerifySecurityQARequest* Arena::CreateMaybeMessage<::erogen::VerifySecurityQARequest>(Arena*);
template<> ::erogen::VerifySecurityQAResponse* Arena::CreateMaybeMessage<::erogen::VerifySecurityQAResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace erogen {

enum ValidateTokenRequest_Scope {
  ValidateTokenRequest_Scope_EMAIL_VERIFICATION = 0,
  ValidateTokenRequest_Scope_PASSWORD_RESET = 1,
  ValidateTokenRequest_Scope_ValidateTokenRequest_Scope_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ValidateTokenRequest_Scope_ValidateTokenRequest_Scope_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ValidateTokenRequest_Scope_IsValid(int value);
const ValidateTokenRequest_Scope ValidateTokenRequest_Scope_Scope_MIN = ValidateTokenRequest_Scope_EMAIL_VERIFICATION;
const ValidateTokenRequest_Scope ValidateTokenRequest_Scope_Scope_MAX = ValidateTokenRequest_Scope_PASSWORD_RESET;
const int ValidateTokenRequest_Scope_Scope_ARRAYSIZE = ValidateTokenRequest_Scope_Scope_MAX + 1;

const ::google::protobuf::EnumDescriptor* ValidateTokenRequest_Scope_descriptor();
inline const ::std::string& ValidateTokenRequest_Scope_Name(ValidateTokenRequest_Scope value) {
  return ::google::protobuf::internal::NameOfEnum(
    ValidateTokenRequest_Scope_descriptor(), value);
}
inline bool ValidateTokenRequest_Scope_Parse(
    const ::std::string& name, ValidateTokenRequest_Scope* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ValidateTokenRequest_Scope>(
    ValidateTokenRequest_Scope_descriptor(), name, value);
}
enum UserIdentifierType {
  UNKNOWN = 0,
  USERNAME = 1,
  EMAIL_ADDRESS = 2,
  MOBILE_NUMBER = 3,
  UserIdentifierType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  UserIdentifierType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool UserIdentifierType_IsValid(int value);
const UserIdentifierType UserIdentifierType_MIN = UNKNOWN;
const UserIdentifierType UserIdentifierType_MAX = MOBILE_NUMBER;
const int UserIdentifierType_ARRAYSIZE = UserIdentifierType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserIdentifierType_descriptor();
inline const ::std::string& UserIdentifierType_Name(UserIdentifierType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserIdentifierType_descriptor(), value);
}
inline bool UserIdentifierType_Parse(
    const ::std::string& name, UserIdentifierType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserIdentifierType>(
    UserIdentifierType_descriptor(), name, value);
}
// ===================================================================

class LoginRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LoginRequest* other);
  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const final {
    return CreateMaybeMessage<LoginRequest>(nullptr);
  }

  LoginRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string identifier = 1;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  const ::std::string& identifier() const;
  void set_identifier(const ::std::string& value);
  #if LANG_CXX11
  void set_identifier(::std::string&& value);
  #endif
  void set_identifier(const char* value);
  void set_identifier(const char* value, size_t size);
  ::std::string* mutable_identifier();
  ::std::string* release_identifier();
  void set_allocated_identifier(::std::string* identifier);

  // string password = 3;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // .erogen.UserIdentifierType identifier_type = 2;
  void clear_identifier_type();
  static const int kIdentifierTypeFieldNumber = 2;
  ::erogen::UserIdentifierType identifier_type() const;
  void set_identifier_type(::erogen::UserIdentifierType value);

  // uint32 remember_for = 5;
  void clear_remember_for();
  static const int kRememberForFieldNumber = 5;
  ::google::protobuf::uint32 remember_for() const;
  void set_remember_for(::google::protobuf::uint32 value);

  // bool remember = 4;
  void clear_remember();
  static const int kRememberFieldNumber = 4;
  bool remember() const;
  void set_remember(bool value);

  // bool fetch_tokens = 6;
  void clear_fetch_tokens();
  static const int kFetchTokensFieldNumber = 6;
  bool fetch_tokens() const;
  void set_fetch_tokens(bool value);

  // @@protoc_insertion_point(class_scope:erogen.LoginRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr identifier_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  int identifier_type_;
  ::google::protobuf::uint32 remember_for_;
  bool remember_;
  bool fetch_tokens_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse_TokenPayload final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.LoginResponse.TokenPayload) */ {
 public:
  LoginResponse_TokenPayload();
  virtual ~LoginResponse_TokenPayload();

  LoginResponse_TokenPayload(const LoginResponse_TokenPayload& from);

  inline LoginResponse_TokenPayload& operator=(const LoginResponse_TokenPayload& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginResponse_TokenPayload(LoginResponse_TokenPayload&& from) noexcept
    : LoginResponse_TokenPayload() {
    *this = ::std::move(from);
  }

  inline LoginResponse_TokenPayload& operator=(LoginResponse_TokenPayload&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LoginResponse_TokenPayload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginResponse_TokenPayload* internal_default_instance() {
    return reinterpret_cast<const LoginResponse_TokenPayload*>(
               &_LoginResponse_TokenPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LoginResponse_TokenPayload* other);
  friend void swap(LoginResponse_TokenPayload& a, LoginResponse_TokenPayload& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginResponse_TokenPayload* New() const final {
    return CreateMaybeMessage<LoginResponse_TokenPayload>(nullptr);
  }

  LoginResponse_TokenPayload* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginResponse_TokenPayload>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginResponse_TokenPayload& from);
  void MergeFrom(const LoginResponse_TokenPayload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse_TokenPayload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id_token = 1;
  void clear_id_token();
  static const int kIdTokenFieldNumber = 1;
  const ::std::string& id_token() const;
  void set_id_token(const ::std::string& value);
  #if LANG_CXX11
  void set_id_token(::std::string&& value);
  #endif
  void set_id_token(const char* value);
  void set_id_token(const char* value, size_t size);
  ::std::string* mutable_id_token();
  ::std::string* release_id_token();
  void set_allocated_id_token(::std::string* id_token);

  // string access_token = 2;
  void clear_access_token();
  static const int kAccessTokenFieldNumber = 2;
  const ::std::string& access_token() const;
  void set_access_token(const ::std::string& value);
  #if LANG_CXX11
  void set_access_token(::std::string&& value);
  #endif
  void set_access_token(const char* value);
  void set_access_token(const char* value, size_t size);
  ::std::string* mutable_access_token();
  ::std::string* release_access_token();
  void set_allocated_access_token(::std::string* access_token);

  // string refresh_token = 3;
  void clear_refresh_token();
  static const int kRefreshTokenFieldNumber = 3;
  const ::std::string& refresh_token() const;
  void set_refresh_token(const ::std::string& value);
  #if LANG_CXX11
  void set_refresh_token(::std::string&& value);
  #endif
  void set_refresh_token(const char* value);
  void set_refresh_token(const char* value, size_t size);
  ::std::string* mutable_refresh_token();
  ::std::string* release_refresh_token();
  void set_allocated_refresh_token(::std::string* refresh_token);

  // string token_type = 4;
  void clear_token_type();
  static const int kTokenTypeFieldNumber = 4;
  const ::std::string& token_type() const;
  void set_token_type(const ::std::string& value);
  #if LANG_CXX11
  void set_token_type(::std::string&& value);
  #endif
  void set_token_type(const char* value);
  void set_token_type(const char* value, size_t size);
  ::std::string* mutable_token_type();
  ::std::string* release_token_type();
  void set_allocated_token_type(::std::string* token_type);

  // string scope = 5;
  void clear_scope();
  static const int kScopeFieldNumber = 5;
  const ::std::string& scope() const;
  void set_scope(const ::std::string& value);
  #if LANG_CXX11
  void set_scope(::std::string&& value);
  #endif
  void set_scope(const char* value);
  void set_scope(const char* value, size_t size);
  ::std::string* mutable_scope();
  ::std::string* release_scope();
  void set_allocated_scope(::std::string* scope);

  // int32 expires_in = 6;
  void clear_expires_in();
  static const int kExpiresInFieldNumber = 6;
  ::google::protobuf::int32 expires_in() const;
  void set_expires_in(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:erogen.LoginResponse.TokenPayload)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_token_;
  ::google::protobuf::internal::ArenaStringPtr access_token_;
  ::google::protobuf::internal::ArenaStringPtr refresh_token_;
  ::google::protobuf::internal::ArenaStringPtr token_type_;
  ::google::protobuf::internal::ArenaStringPtr scope_;
  ::google::protobuf::int32 expires_in_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.LoginResponse) */ {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LoginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LoginResponse* other);
  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const final {
    return CreateMaybeMessage<LoginResponse>(nullptr);
  }

  LoginResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LoginResponse_TokenPayload TokenPayload;

  // accessors -------------------------------------------------------

  // .erogen.LoginResponse.TokenPayload payload = 2;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::erogen::LoginResponse_TokenPayload& payload() const;
  ::erogen::LoginResponse_TokenPayload* release_payload();
  ::erogen::LoginResponse_TokenPayload* mutable_payload();
  void set_allocated_payload(::erogen::LoginResponse_TokenPayload* payload);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:erogen.LoginResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::erogen::LoginResponse_TokenPayload* payload_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.RegisterRequest) */ {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegisterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RegisterRequest* other);
  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterRequest* New() const final {
    return CreateMaybeMessage<RegisterRequest>(nullptr);
  }

  RegisterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string email_address = 2;
  void clear_email_address();
  static const int kEmailAddressFieldNumber = 2;
  const ::std::string& email_address() const;
  void set_email_address(const ::std::string& value);
  #if LANG_CXX11
  void set_email_address(::std::string&& value);
  #endif
  void set_email_address(const char* value);
  void set_email_address(const char* value, size_t size);
  ::std::string* mutable_email_address();
  ::std::string* release_email_address();
  void set_allocated_email_address(::std::string* email_address);

  // string password = 3;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // string accepted_tos_version = 4;
  void clear_accepted_tos_version();
  static const int kAcceptedTosVersionFieldNumber = 4;
  const ::std::string& accepted_tos_version() const;
  void set_accepted_tos_version(const ::std::string& value);
  #if LANG_CXX11
  void set_accepted_tos_version(::std::string&& value);
  #endif
  void set_accepted_tos_version(const char* value);
  void set_accepted_tos_version(const char* value, size_t size);
  ::std::string* mutable_accepted_tos_version();
  ::std::string* release_accepted_tos_version();
  void set_allocated_accepted_tos_version(::std::string* accepted_tos_version);

  // @@protoc_insertion_point(class_scope:erogen.RegisterRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr email_address_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr accepted_tos_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.RegisterResponse) */ {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RegisterResponse* other);
  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponse* New() const final {
    return CreateMaybeMessage<RegisterResponse>(nullptr);
  }

  RegisterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:erogen.RegisterResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ChangeEmailRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.ChangeEmailRequest) */ {
 public:
  ChangeEmailRequest();
  virtual ~ChangeEmailRequest();

  ChangeEmailRequest(const ChangeEmailRequest& from);

  inline ChangeEmailRequest& operator=(const ChangeEmailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeEmailRequest(ChangeEmailRequest&& from) noexcept
    : ChangeEmailRequest() {
    *this = ::std::move(from);
  }

  inline ChangeEmailRequest& operator=(ChangeEmailRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChangeEmailRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeEmailRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeEmailRequest*>(
               &_ChangeEmailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ChangeEmailRequest* other);
  friend void swap(ChangeEmailRequest& a, ChangeEmailRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeEmailRequest* New() const final {
    return CreateMaybeMessage<ChangeEmailRequest>(nullptr);
  }

  ChangeEmailRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangeEmailRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangeEmailRequest& from);
  void MergeFrom(const ChangeEmailRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeEmailRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string current_email = 2;
  void clear_current_email();
  static const int kCurrentEmailFieldNumber = 2;
  const ::std::string& current_email() const;
  void set_current_email(const ::std::string& value);
  #if LANG_CXX11
  void set_current_email(::std::string&& value);
  #endif
  void set_current_email(const char* value);
  void set_current_email(const char* value, size_t size);
  ::std::string* mutable_current_email();
  ::std::string* release_current_email();
  void set_allocated_current_email(::std::string* current_email);

  // string new_email = 3;
  void clear_new_email();
  static const int kNewEmailFieldNumber = 3;
  const ::std::string& new_email() const;
  void set_new_email(const ::std::string& value);
  #if LANG_CXX11
  void set_new_email(::std::string&& value);
  #endif
  void set_new_email(const char* value);
  void set_new_email(const char* value, size_t size);
  ::std::string* mutable_new_email();
  ::std::string* release_new_email();
  void set_allocated_new_email(::std::string* new_email);

  // @@protoc_insertion_point(class_scope:erogen.ChangeEmailRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr current_email_;
  ::google::protobuf::internal::ArenaStringPtr new_email_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ChangeEmailResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.ChangeEmailResponse) */ {
 public:
  ChangeEmailResponse();
  virtual ~ChangeEmailResponse();

  ChangeEmailResponse(const ChangeEmailResponse& from);

  inline ChangeEmailResponse& operator=(const ChangeEmailResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeEmailResponse(ChangeEmailResponse&& from) noexcept
    : ChangeEmailResponse() {
    *this = ::std::move(from);
  }

  inline ChangeEmailResponse& operator=(ChangeEmailResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChangeEmailResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeEmailResponse* internal_default_instance() {
    return reinterpret_cast<const ChangeEmailResponse*>(
               &_ChangeEmailResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ChangeEmailResponse* other);
  friend void swap(ChangeEmailResponse& a, ChangeEmailResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeEmailResponse* New() const final {
    return CreateMaybeMessage<ChangeEmailResponse>(nullptr);
  }

  ChangeEmailResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangeEmailResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangeEmailResponse& from);
  void MergeFrom(const ChangeEmailResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeEmailResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:erogen.ChangeEmailResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ChangeUsernameRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.ChangeUsernameRequest) */ {
 public:
  ChangeUsernameRequest();
  virtual ~ChangeUsernameRequest();

  ChangeUsernameRequest(const ChangeUsernameRequest& from);

  inline ChangeUsernameRequest& operator=(const ChangeUsernameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeUsernameRequest(ChangeUsernameRequest&& from) noexcept
    : ChangeUsernameRequest() {
    *this = ::std::move(from);
  }

  inline ChangeUsernameRequest& operator=(ChangeUsernameRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChangeUsernameRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeUsernameRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeUsernameRequest*>(
               &_ChangeUsernameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ChangeUsernameRequest* other);
  friend void swap(ChangeUsernameRequest& a, ChangeUsernameRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeUsernameRequest* New() const final {
    return CreateMaybeMessage<ChangeUsernameRequest>(nullptr);
  }

  ChangeUsernameRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangeUsernameRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangeUsernameRequest& from);
  void MergeFrom(const ChangeUsernameRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeUsernameRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string current_username = 2;
  void clear_current_username();
  static const int kCurrentUsernameFieldNumber = 2;
  const ::std::string& current_username() const;
  void set_current_username(const ::std::string& value);
  #if LANG_CXX11
  void set_current_username(::std::string&& value);
  #endif
  void set_current_username(const char* value);
  void set_current_username(const char* value, size_t size);
  ::std::string* mutable_current_username();
  ::std::string* release_current_username();
  void set_allocated_current_username(::std::string* current_username);

  // string new_username = 3;
  void clear_new_username();
  static const int kNewUsernameFieldNumber = 3;
  const ::std::string& new_username() const;
  void set_new_username(const ::std::string& value);
  #if LANG_CXX11
  void set_new_username(::std::string&& value);
  #endif
  void set_new_username(const char* value);
  void set_new_username(const char* value, size_t size);
  ::std::string* mutable_new_username();
  ::std::string* release_new_username();
  void set_allocated_new_username(::std::string* new_username);

  // @@protoc_insertion_point(class_scope:erogen.ChangeUsernameRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr current_username_;
  ::google::protobuf::internal::ArenaStringPtr new_username_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ChangeUsernameResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.ChangeUsernameResponse) */ {
 public:
  ChangeUsernameResponse();
  virtual ~ChangeUsernameResponse();

  ChangeUsernameResponse(const ChangeUsernameResponse& from);

  inline ChangeUsernameResponse& operator=(const ChangeUsernameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeUsernameResponse(ChangeUsernameResponse&& from) noexcept
    : ChangeUsernameResponse() {
    *this = ::std::move(from);
  }

  inline ChangeUsernameResponse& operator=(ChangeUsernameResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChangeUsernameResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeUsernameResponse* internal_default_instance() {
    return reinterpret_cast<const ChangeUsernameResponse*>(
               &_ChangeUsernameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ChangeUsernameResponse* other);
  friend void swap(ChangeUsernameResponse& a, ChangeUsernameResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeUsernameResponse* New() const final {
    return CreateMaybeMessage<ChangeUsernameResponse>(nullptr);
  }

  ChangeUsernameResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangeUsernameResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangeUsernameResponse& from);
  void MergeFrom(const ChangeUsernameResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeUsernameResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:erogen.ChangeUsernameResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ChangePasswordRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.ChangePasswordRequest) */ {
 public:
  ChangePasswordRequest();
  virtual ~ChangePasswordRequest();

  ChangePasswordRequest(const ChangePasswordRequest& from);

  inline ChangePasswordRequest& operator=(const ChangePasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangePasswordRequest(ChangePasswordRequest&& from) noexcept
    : ChangePasswordRequest() {
    *this = ::std::move(from);
  }

  inline ChangePasswordRequest& operator=(ChangePasswordRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChangePasswordRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangePasswordRequest* internal_default_instance() {
    return reinterpret_cast<const ChangePasswordRequest*>(
               &_ChangePasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ChangePasswordRequest* other);
  friend void swap(ChangePasswordRequest& a, ChangePasswordRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangePasswordRequest* New() const final {
    return CreateMaybeMessage<ChangePasswordRequest>(nullptr);
  }

  ChangePasswordRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangePasswordRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangePasswordRequest& from);
  void MergeFrom(const ChangePasswordRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangePasswordRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string current_password = 2;
  void clear_current_password();
  static const int kCurrentPasswordFieldNumber = 2;
  const ::std::string& current_password() const;
  void set_current_password(const ::std::string& value);
  #if LANG_CXX11
  void set_current_password(::std::string&& value);
  #endif
  void set_current_password(const char* value);
  void set_current_password(const char* value, size_t size);
  ::std::string* mutable_current_password();
  ::std::string* release_current_password();
  void set_allocated_current_password(::std::string* current_password);

  // string new_password = 3;
  void clear_new_password();
  static const int kNewPasswordFieldNumber = 3;
  const ::std::string& new_password() const;
  void set_new_password(const ::std::string& value);
  #if LANG_CXX11
  void set_new_password(::std::string&& value);
  #endif
  void set_new_password(const char* value);
  void set_new_password(const char* value, size_t size);
  ::std::string* mutable_new_password();
  ::std::string* release_new_password();
  void set_allocated_new_password(::std::string* new_password);

  // @@protoc_insertion_point(class_scope:erogen.ChangePasswordRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr current_password_;
  ::google::protobuf::internal::ArenaStringPtr new_password_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ChangePasswordResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.ChangePasswordResponse) */ {
 public:
  ChangePasswordResponse();
  virtual ~ChangePasswordResponse();

  ChangePasswordResponse(const ChangePasswordResponse& from);

  inline ChangePasswordResponse& operator=(const ChangePasswordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangePasswordResponse(ChangePasswordResponse&& from) noexcept
    : ChangePasswordResponse() {
    *this = ::std::move(from);
  }

  inline ChangePasswordResponse& operator=(ChangePasswordResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChangePasswordResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangePasswordResponse* internal_default_instance() {
    return reinterpret_cast<const ChangePasswordResponse*>(
               &_ChangePasswordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ChangePasswordResponse* other);
  friend void swap(ChangePasswordResponse& a, ChangePasswordResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangePasswordResponse* New() const final {
    return CreateMaybeMessage<ChangePasswordResponse>(nullptr);
  }

  ChangePasswordResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangePasswordResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangePasswordResponse& from);
  void MergeFrom(const ChangePasswordResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangePasswordResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:erogen.ChangePasswordResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ForgotPasswordRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.ForgotPasswordRequest) */ {
 public:
  ForgotPasswordRequest();
  virtual ~ForgotPasswordRequest();

  ForgotPasswordRequest(const ForgotPasswordRequest& from);

  inline ForgotPasswordRequest& operator=(const ForgotPasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ForgotPasswordRequest(ForgotPasswordRequest&& from) noexcept
    : ForgotPasswordRequest() {
    *this = ::std::move(from);
  }

  inline ForgotPasswordRequest& operator=(ForgotPasswordRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ForgotPasswordRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ForgotPasswordRequest* internal_default_instance() {
    return reinterpret_cast<const ForgotPasswordRequest*>(
               &_ForgotPasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ForgotPasswordRequest* other);
  friend void swap(ForgotPasswordRequest& a, ForgotPasswordRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ForgotPasswordRequest* New() const final {
    return CreateMaybeMessage<ForgotPasswordRequest>(nullptr);
  }

  ForgotPasswordRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ForgotPasswordRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ForgotPasswordRequest& from);
  void MergeFrom(const ForgotPasswordRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForgotPasswordRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string email_address = 1;
  void clear_email_address();
  static const int kEmailAddressFieldNumber = 1;
  const ::std::string& email_address() const;
  void set_email_address(const ::std::string& value);
  #if LANG_CXX11
  void set_email_address(::std::string&& value);
  #endif
  void set_email_address(const char* value);
  void set_email_address(const char* value, size_t size);
  ::std::string* mutable_email_address();
  ::std::string* release_email_address();
  void set_allocated_email_address(::std::string* email_address);

  // @@protoc_insertion_point(class_scope:erogen.ForgotPasswordRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr email_address_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ForgotPasswordResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.ForgotPasswordResponse) */ {
 public:
  ForgotPasswordResponse();
  virtual ~ForgotPasswordResponse();

  ForgotPasswordResponse(const ForgotPasswordResponse& from);

  inline ForgotPasswordResponse& operator=(const ForgotPasswordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ForgotPasswordResponse(ForgotPasswordResponse&& from) noexcept
    : ForgotPasswordResponse() {
    *this = ::std::move(from);
  }

  inline ForgotPasswordResponse& operator=(ForgotPasswordResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ForgotPasswordResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ForgotPasswordResponse* internal_default_instance() {
    return reinterpret_cast<const ForgotPasswordResponse*>(
               &_ForgotPasswordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ForgotPasswordResponse* other);
  friend void swap(ForgotPasswordResponse& a, ForgotPasswordResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ForgotPasswordResponse* New() const final {
    return CreateMaybeMessage<ForgotPasswordResponse>(nullptr);
  }

  ForgotPasswordResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ForgotPasswordResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ForgotPasswordResponse& from);
  void MergeFrom(const ForgotPasswordResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForgotPasswordResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool user_exists = 1;
  void clear_user_exists();
  static const int kUserExistsFieldNumber = 1;
  bool user_exists() const;
  void set_user_exists(bool value);

  // bool sendemail_queued = 2;
  void clear_sendemail_queued();
  static const int kSendemailQueuedFieldNumber = 2;
  bool sendemail_queued() const;
  void set_sendemail_queued(bool value);

  // @@protoc_insertion_point(class_scope:erogen.ForgotPasswordResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool user_exists_;
  bool sendemail_queued_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ResetPasswordRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.ResetPasswordRequest) */ {
 public:
  ResetPasswordRequest();
  virtual ~ResetPasswordRequest();

  ResetPasswordRequest(const ResetPasswordRequest& from);

  inline ResetPasswordRequest& operator=(const ResetPasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResetPasswordRequest(ResetPasswordRequest&& from) noexcept
    : ResetPasswordRequest() {
    *this = ::std::move(from);
  }

  inline ResetPasswordRequest& operator=(ResetPasswordRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ResetPasswordRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetPasswordRequest* internal_default_instance() {
    return reinterpret_cast<const ResetPasswordRequest*>(
               &_ResetPasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ResetPasswordRequest* other);
  friend void swap(ResetPasswordRequest& a, ResetPasswordRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResetPasswordRequest* New() const final {
    return CreateMaybeMessage<ResetPasswordRequest>(nullptr);
  }

  ResetPasswordRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResetPasswordRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResetPasswordRequest& from);
  void MergeFrom(const ResetPasswordRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetPasswordRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_id = 1;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // string new_password = 2;
  void clear_new_password();
  static const int kNewPasswordFieldNumber = 2;
  const ::std::string& new_password() const;
  void set_new_password(const ::std::string& value);
  #if LANG_CXX11
  void set_new_password(::std::string&& value);
  #endif
  void set_new_password(const char* value);
  void set_new_password(const char* value, size_t size);
  ::std::string* mutable_new_password();
  ::std::string* release_new_password();
  void set_allocated_new_password(::std::string* new_password);

  // @@protoc_insertion_point(class_scope:erogen.ResetPasswordRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr new_password_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ResetPasswordResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.ResetPasswordResponse) */ {
 public:
  ResetPasswordResponse();
  virtual ~ResetPasswordResponse();

  ResetPasswordResponse(const ResetPasswordResponse& from);

  inline ResetPasswordResponse& operator=(const ResetPasswordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResetPasswordResponse(ResetPasswordResponse&& from) noexcept
    : ResetPasswordResponse() {
    *this = ::std::move(from);
  }

  inline ResetPasswordResponse& operator=(ResetPasswordResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ResetPasswordResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetPasswordResponse* internal_default_instance() {
    return reinterpret_cast<const ResetPasswordResponse*>(
               &_ResetPasswordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ResetPasswordResponse* other);
  friend void swap(ResetPasswordResponse& a, ResetPasswordResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResetPasswordResponse* New() const final {
    return CreateMaybeMessage<ResetPasswordResponse>(nullptr);
  }

  ResetPasswordResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResetPasswordResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResetPasswordResponse& from);
  void MergeFrom(const ResetPasswordResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetPasswordResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:erogen.ResetPasswordResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ValidateTokenRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.ValidateTokenRequest) */ {
 public:
  ValidateTokenRequest();
  virtual ~ValidateTokenRequest();

  ValidateTokenRequest(const ValidateTokenRequest& from);

  inline ValidateTokenRequest& operator=(const ValidateTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ValidateTokenRequest(ValidateTokenRequest&& from) noexcept
    : ValidateTokenRequest() {
    *this = ::std::move(from);
  }

  inline ValidateTokenRequest& operator=(ValidateTokenRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ValidateTokenRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidateTokenRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateTokenRequest*>(
               &_ValidateTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ValidateTokenRequest* other);
  friend void swap(ValidateTokenRequest& a, ValidateTokenRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValidateTokenRequest* New() const final {
    return CreateMaybeMessage<ValidateTokenRequest>(nullptr);
  }

  ValidateTokenRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ValidateTokenRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ValidateTokenRequest& from);
  void MergeFrom(const ValidateTokenRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateTokenRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ValidateTokenRequest_Scope Scope;
  static const Scope EMAIL_VERIFICATION =
    ValidateTokenRequest_Scope_EMAIL_VERIFICATION;
  static const Scope PASSWORD_RESET =
    ValidateTokenRequest_Scope_PASSWORD_RESET;
  static inline bool Scope_IsValid(int value) {
    return ValidateTokenRequest_Scope_IsValid(value);
  }
  static const Scope Scope_MIN =
    ValidateTokenRequest_Scope_Scope_MIN;
  static const Scope Scope_MAX =
    ValidateTokenRequest_Scope_Scope_MAX;
  static const int Scope_ARRAYSIZE =
    ValidateTokenRequest_Scope_Scope_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Scope_descriptor() {
    return ValidateTokenRequest_Scope_descriptor();
  }
  static inline const ::std::string& Scope_Name(Scope value) {
    return ValidateTokenRequest_Scope_Name(value);
  }
  static inline bool Scope_Parse(const ::std::string& name,
      Scope* value) {
    return ValidateTokenRequest_Scope_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // .erogen.ValidateTokenRequest.Scope scope = 2;
  void clear_scope();
  static const int kScopeFieldNumber = 2;
  ::erogen::ValidateTokenRequest_Scope scope() const;
  void set_scope(::erogen::ValidateTokenRequest_Scope value);

  // @@protoc_insertion_point(class_scope:erogen.ValidateTokenRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  int scope_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class ValidateTokenResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.ValidateTokenResponse) */ {
 public:
  ValidateTokenResponse();
  virtual ~ValidateTokenResponse();

  ValidateTokenResponse(const ValidateTokenResponse& from);

  inline ValidateTokenResponse& operator=(const ValidateTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ValidateTokenResponse(ValidateTokenResponse&& from) noexcept
    : ValidateTokenResponse() {
    *this = ::std::move(from);
  }

  inline ValidateTokenResponse& operator=(ValidateTokenResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ValidateTokenResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidateTokenResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateTokenResponse*>(
               &_ValidateTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ValidateTokenResponse* other);
  friend void swap(ValidateTokenResponse& a, ValidateTokenResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValidateTokenResponse* New() const final {
    return CreateMaybeMessage<ValidateTokenResponse>(nullptr);
  }

  ValidateTokenResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ValidateTokenResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ValidateTokenResponse& from);
  void MergeFrom(const ValidateTokenResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateTokenResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:erogen.ValidateTokenResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class VerifySecurityQARequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.VerifySecurityQARequest) */ {
 public:
  VerifySecurityQARequest();
  virtual ~VerifySecurityQARequest();

  VerifySecurityQARequest(const VerifySecurityQARequest& from);

  inline VerifySecurityQARequest& operator=(const VerifySecurityQARequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VerifySecurityQARequest(VerifySecurityQARequest&& from) noexcept
    : VerifySecurityQARequest() {
    *this = ::std::move(from);
  }

  inline VerifySecurityQARequest& operator=(VerifySecurityQARequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VerifySecurityQARequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VerifySecurityQARequest* internal_default_instance() {
    return reinterpret_cast<const VerifySecurityQARequest*>(
               &_VerifySecurityQARequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(VerifySecurityQARequest* other);
  friend void swap(VerifySecurityQARequest& a, VerifySecurityQARequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VerifySecurityQARequest* New() const final {
    return CreateMaybeMessage<VerifySecurityQARequest>(nullptr);
  }

  VerifySecurityQARequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VerifySecurityQARequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VerifySecurityQARequest& from);
  void MergeFrom(const VerifySecurityQARequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifySecurityQARequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string answer = 1;
  void clear_answer();
  static const int kAnswerFieldNumber = 1;
  const ::std::string& answer() const;
  void set_answer(const ::std::string& value);
  #if LANG_CXX11
  void set_answer(::std::string&& value);
  #endif
  void set_answer(const char* value);
  void set_answer(const char* value, size_t size);
  ::std::string* mutable_answer();
  ::std::string* release_answer();
  void set_allocated_answer(::std::string* answer);

  // @@protoc_insertion_point(class_scope:erogen.VerifySecurityQARequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr answer_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class VerifySecurityQAResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.VerifySecurityQAResponse) */ {
 public:
  VerifySecurityQAResponse();
  virtual ~VerifySecurityQAResponse();

  VerifySecurityQAResponse(const VerifySecurityQAResponse& from);

  inline VerifySecurityQAResponse& operator=(const VerifySecurityQAResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VerifySecurityQAResponse(VerifySecurityQAResponse&& from) noexcept
    : VerifySecurityQAResponse() {
    *this = ::std::move(from);
  }

  inline VerifySecurityQAResponse& operator=(VerifySecurityQAResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VerifySecurityQAResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VerifySecurityQAResponse* internal_default_instance() {
    return reinterpret_cast<const VerifySecurityQAResponse*>(
               &_VerifySecurityQAResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(VerifySecurityQAResponse* other);
  friend void swap(VerifySecurityQAResponse& a, VerifySecurityQAResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VerifySecurityQAResponse* New() const final {
    return CreateMaybeMessage<VerifySecurityQAResponse>(nullptr);
  }

  VerifySecurityQAResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VerifySecurityQAResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VerifySecurityQAResponse& from);
  void MergeFrom(const VerifySecurityQAResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifySecurityQAResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:erogen.VerifySecurityQAResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.UpdateRequest) */ {
 public:
  UpdateRequest();
  virtual ~UpdateRequest();

  UpdateRequest(const UpdateRequest& from);

  inline UpdateRequest& operator=(const UpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateRequest(UpdateRequest&& from) noexcept
    : UpdateRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRequest& operator=(UpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRequest*>(
               &_UpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(UpdateRequest* other);
  friend void swap(UpdateRequest& a, UpdateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateRequest* New() const final {
    return CreateMaybeMessage<UpdateRequest>(nullptr);
  }

  UpdateRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateRequest& from);
  void MergeFrom(const UpdateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .erogen.User user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::erogen::User& user() const;
  ::erogen::User* release_user();
  ::erogen::User* mutable_user();
  void set_allocated_user(::erogen::User* user);

  // @@protoc_insertion_point(class_scope:erogen.UpdateRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::erogen::User* user_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UpdateResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.UpdateResponse) */ {
 public:
  UpdateResponse();
  virtual ~UpdateResponse();

  UpdateResponse(const UpdateResponse& from);

  inline UpdateResponse& operator=(const UpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateResponse(UpdateResponse&& from) noexcept
    : UpdateResponse() {
    *this = ::std::move(from);
  }

  inline UpdateResponse& operator=(UpdateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateResponse*>(
               &_UpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(UpdateResponse* other);
  friend void swap(UpdateResponse& a, UpdateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateResponse* New() const final {
    return CreateMaybeMessage<UpdateResponse>(nullptr);
  }

  UpdateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateResponse& from);
  void MergeFrom(const UpdateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .erogen.User user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  const ::erogen::User& user() const;
  ::erogen::User* release_user();
  ::erogen::User* mutable_user();
  void set_allocated_user(::erogen::User* user);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:erogen.UpdateResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::erogen::User* user_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.DeleteRequest) */ {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DeleteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(DeleteRequest* other);
  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const final {
    return CreateMaybeMessage<DeleteRequest>(nullptr);
  }

  DeleteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:erogen.DeleteRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class DeleteResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.DeleteResponse) */ {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();

  DeleteResponse(const DeleteResponse& from);

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DeleteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(DeleteResponse* other);
  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteResponse* New() const final {
    return CreateMaybeMessage<DeleteResponse>(nullptr);
  }

  DeleteResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:erogen.DeleteResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UserRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.UserRequest) */ {
 public:
  UserRequest();
  virtual ~UserRequest();

  UserRequest(const UserRequest& from);

  inline UserRequest& operator=(const UserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRequest(UserRequest&& from) noexcept
    : UserRequest() {
    *this = ::std::move(from);
  }

  inline UserRequest& operator=(UserRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRequest* internal_default_instance() {
    return reinterpret_cast<const UserRequest*>(
               &_UserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(UserRequest* other);
  friend void swap(UserRequest& a, UserRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRequest* New() const final {
    return CreateMaybeMessage<UserRequest>(nullptr);
  }

  UserRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRequest& from);
  void MergeFrom(const UserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:erogen.UserRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UserResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.UserResponse) */ {
 public:
  UserResponse();
  virtual ~UserResponse();

  UserResponse(const UserResponse& from);

  inline UserResponse& operator=(const UserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserResponse(UserResponse&& from) noexcept
    : UserResponse() {
    *this = ::std::move(from);
  }

  inline UserResponse& operator=(UserResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserResponse* internal_default_instance() {
    return reinterpret_cast<const UserResponse*>(
               &_UserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(UserResponse* other);
  friend void swap(UserResponse& a, UserResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserResponse* New() const final {
    return CreateMaybeMessage<UserResponse>(nullptr);
  }

  UserResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserResponse& from);
  void MergeFrom(const UserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .erogen.User user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::erogen::User& user() const;
  ::erogen::User* release_user();
  ::erogen::User* mutable_user();
  void set_allocated_user(::erogen::User* user);

  // @@protoc_insertion_point(class_scope:erogen.UserResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::erogen::User* user_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UsersRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.UsersRequest) */ {
 public:
  UsersRequest();
  virtual ~UsersRequest();

  UsersRequest(const UsersRequest& from);

  inline UsersRequest& operator=(const UsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UsersRequest(UsersRequest&& from) noexcept
    : UsersRequest() {
    *this = ::std::move(from);
  }

  inline UsersRequest& operator=(UsersRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UsersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsersRequest* internal_default_instance() {
    return reinterpret_cast<const UsersRequest*>(
               &_UsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(UsersRequest* other);
  friend void swap(UsersRequest& a, UsersRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UsersRequest* New() const final {
    return CreateMaybeMessage<UsersRequest>(nullptr);
  }

  UsersRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UsersRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UsersRequest& from);
  void MergeFrom(const UsersRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filter = 1;
  void clear_filter();
  static const int kFilterFieldNumber = 1;
  const ::std::string& filter() const;
  void set_filter(const ::std::string& value);
  #if LANG_CXX11
  void set_filter(::std::string&& value);
  #endif
  void set_filter(const char* value);
  void set_filter(const char* value, size_t size);
  ::std::string* mutable_filter();
  ::std::string* release_filter();
  void set_allocated_filter(::std::string* filter);

  // uint32 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // uint32 offset = 3;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:erogen.UsersRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filter_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 offset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:erogen.User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(User&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(User* other);
  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User* New() const final {
    return CreateMaybeMessage<User>(nullptr);
  }

  User* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:erogen.User)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fuser_2fuser_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginRequest

// string identifier = 1;
inline void LoginRequest::clear_identifier() {
  identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::identifier() const {
  // @@protoc_insertion_point(field_get:erogen.LoginRequest.identifier)
  return identifier_.GetNoArena();
}
inline void LoginRequest::set_identifier(const ::std::string& value) {
  
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.LoginRequest.identifier)
}
#if LANG_CXX11
inline void LoginRequest::set_identifier(::std::string&& value) {
  
  identifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.LoginRequest.identifier)
}
#endif
inline void LoginRequest::set_identifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.LoginRequest.identifier)
}
inline void LoginRequest::set_identifier(const char* value, size_t size) {
  
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.LoginRequest.identifier)
}
inline ::std::string* LoginRequest::mutable_identifier() {
  
  // @@protoc_insertion_point(field_mutable:erogen.LoginRequest.identifier)
  return identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_identifier() {
  // @@protoc_insertion_point(field_release:erogen.LoginRequest.identifier)
  
  return identifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_identifier(::std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), identifier);
  // @@protoc_insertion_point(field_set_allocated:erogen.LoginRequest.identifier)
}

// .erogen.UserIdentifierType identifier_type = 2;
inline void LoginRequest::clear_identifier_type() {
  identifier_type_ = 0;
}
inline ::erogen::UserIdentifierType LoginRequest::identifier_type() const {
  // @@protoc_insertion_point(field_get:erogen.LoginRequest.identifier_type)
  return static_cast< ::erogen::UserIdentifierType >(identifier_type_);
}
inline void LoginRequest::set_identifier_type(::erogen::UserIdentifierType value) {
  
  identifier_type_ = value;
  // @@protoc_insertion_point(field_set:erogen.LoginRequest.identifier_type)
}

// string password = 3;
inline void LoginRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:erogen.LoginRequest.password)
  return password_.GetNoArena();
}
inline void LoginRequest::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.LoginRequest.password)
}
#if LANG_CXX11
inline void LoginRequest::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.LoginRequest.password)
}
#endif
inline void LoginRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.LoginRequest.password)
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.LoginRequest.password)
}
inline ::std::string* LoginRequest::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:erogen.LoginRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:erogen.LoginRequest.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:erogen.LoginRequest.password)
}

// bool remember = 4;
inline void LoginRequest::clear_remember() {
  remember_ = false;
}
inline bool LoginRequest::remember() const {
  // @@protoc_insertion_point(field_get:erogen.LoginRequest.remember)
  return remember_;
}
inline void LoginRequest::set_remember(bool value) {
  
  remember_ = value;
  // @@protoc_insertion_point(field_set:erogen.LoginRequest.remember)
}

// uint32 remember_for = 5;
inline void LoginRequest::clear_remember_for() {
  remember_for_ = 0u;
}
inline ::google::protobuf::uint32 LoginRequest::remember_for() const {
  // @@protoc_insertion_point(field_get:erogen.LoginRequest.remember_for)
  return remember_for_;
}
inline void LoginRequest::set_remember_for(::google::protobuf::uint32 value) {
  
  remember_for_ = value;
  // @@protoc_insertion_point(field_set:erogen.LoginRequest.remember_for)
}

// bool fetch_tokens = 6;
inline void LoginRequest::clear_fetch_tokens() {
  fetch_tokens_ = false;
}
inline bool LoginRequest::fetch_tokens() const {
  // @@protoc_insertion_point(field_get:erogen.LoginRequest.fetch_tokens)
  return fetch_tokens_;
}
inline void LoginRequest::set_fetch_tokens(bool value) {
  
  fetch_tokens_ = value;
  // @@protoc_insertion_point(field_set:erogen.LoginRequest.fetch_tokens)
}

// -------------------------------------------------------------------

// LoginResponse_TokenPayload

// string id_token = 1;
inline void LoginResponse_TokenPayload::clear_id_token() {
  id_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginResponse_TokenPayload::id_token() const {
  // @@protoc_insertion_point(field_get:erogen.LoginResponse.TokenPayload.id_token)
  return id_token_.GetNoArena();
}
inline void LoginResponse_TokenPayload::set_id_token(const ::std::string& value) {
  
  id_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.LoginResponse.TokenPayload.id_token)
}
#if LANG_CXX11
inline void LoginResponse_TokenPayload::set_id_token(::std::string&& value) {
  
  id_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.LoginResponse.TokenPayload.id_token)
}
#endif
inline void LoginResponse_TokenPayload::set_id_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.LoginResponse.TokenPayload.id_token)
}
inline void LoginResponse_TokenPayload::set_id_token(const char* value, size_t size) {
  
  id_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.LoginResponse.TokenPayload.id_token)
}
inline ::std::string* LoginResponse_TokenPayload::mutable_id_token() {
  
  // @@protoc_insertion_point(field_mutable:erogen.LoginResponse.TokenPayload.id_token)
  return id_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse_TokenPayload::release_id_token() {
  // @@protoc_insertion_point(field_release:erogen.LoginResponse.TokenPayload.id_token)
  
  return id_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse_TokenPayload::set_allocated_id_token(::std::string* id_token) {
  if (id_token != nullptr) {
    
  } else {
    
  }
  id_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id_token);
  // @@protoc_insertion_point(field_set_allocated:erogen.LoginResponse.TokenPayload.id_token)
}

// string access_token = 2;
inline void LoginResponse_TokenPayload::clear_access_token() {
  access_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginResponse_TokenPayload::access_token() const {
  // @@protoc_insertion_point(field_get:erogen.LoginResponse.TokenPayload.access_token)
  return access_token_.GetNoArena();
}
inline void LoginResponse_TokenPayload::set_access_token(const ::std::string& value) {
  
  access_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.LoginResponse.TokenPayload.access_token)
}
#if LANG_CXX11
inline void LoginResponse_TokenPayload::set_access_token(::std::string&& value) {
  
  access_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.LoginResponse.TokenPayload.access_token)
}
#endif
inline void LoginResponse_TokenPayload::set_access_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  access_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.LoginResponse.TokenPayload.access_token)
}
inline void LoginResponse_TokenPayload::set_access_token(const char* value, size_t size) {
  
  access_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.LoginResponse.TokenPayload.access_token)
}
inline ::std::string* LoginResponse_TokenPayload::mutable_access_token() {
  
  // @@protoc_insertion_point(field_mutable:erogen.LoginResponse.TokenPayload.access_token)
  return access_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse_TokenPayload::release_access_token() {
  // @@protoc_insertion_point(field_release:erogen.LoginResponse.TokenPayload.access_token)
  
  return access_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse_TokenPayload::set_allocated_access_token(::std::string* access_token) {
  if (access_token != nullptr) {
    
  } else {
    
  }
  access_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), access_token);
  // @@protoc_insertion_point(field_set_allocated:erogen.LoginResponse.TokenPayload.access_token)
}

// string refresh_token = 3;
inline void LoginResponse_TokenPayload::clear_refresh_token() {
  refresh_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginResponse_TokenPayload::refresh_token() const {
  // @@protoc_insertion_point(field_get:erogen.LoginResponse.TokenPayload.refresh_token)
  return refresh_token_.GetNoArena();
}
inline void LoginResponse_TokenPayload::set_refresh_token(const ::std::string& value) {
  
  refresh_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.LoginResponse.TokenPayload.refresh_token)
}
#if LANG_CXX11
inline void LoginResponse_TokenPayload::set_refresh_token(::std::string&& value) {
  
  refresh_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.LoginResponse.TokenPayload.refresh_token)
}
#endif
inline void LoginResponse_TokenPayload::set_refresh_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  refresh_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.LoginResponse.TokenPayload.refresh_token)
}
inline void LoginResponse_TokenPayload::set_refresh_token(const char* value, size_t size) {
  
  refresh_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.LoginResponse.TokenPayload.refresh_token)
}
inline ::std::string* LoginResponse_TokenPayload::mutable_refresh_token() {
  
  // @@protoc_insertion_point(field_mutable:erogen.LoginResponse.TokenPayload.refresh_token)
  return refresh_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse_TokenPayload::release_refresh_token() {
  // @@protoc_insertion_point(field_release:erogen.LoginResponse.TokenPayload.refresh_token)
  
  return refresh_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse_TokenPayload::set_allocated_refresh_token(::std::string* refresh_token) {
  if (refresh_token != nullptr) {
    
  } else {
    
  }
  refresh_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), refresh_token);
  // @@protoc_insertion_point(field_set_allocated:erogen.LoginResponse.TokenPayload.refresh_token)
}

// string token_type = 4;
inline void LoginResponse_TokenPayload::clear_token_type() {
  token_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginResponse_TokenPayload::token_type() const {
  // @@protoc_insertion_point(field_get:erogen.LoginResponse.TokenPayload.token_type)
  return token_type_.GetNoArena();
}
inline void LoginResponse_TokenPayload::set_token_type(const ::std::string& value) {
  
  token_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.LoginResponse.TokenPayload.token_type)
}
#if LANG_CXX11
inline void LoginResponse_TokenPayload::set_token_type(::std::string&& value) {
  
  token_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.LoginResponse.TokenPayload.token_type)
}
#endif
inline void LoginResponse_TokenPayload::set_token_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.LoginResponse.TokenPayload.token_type)
}
inline void LoginResponse_TokenPayload::set_token_type(const char* value, size_t size) {
  
  token_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.LoginResponse.TokenPayload.token_type)
}
inline ::std::string* LoginResponse_TokenPayload::mutable_token_type() {
  
  // @@protoc_insertion_point(field_mutable:erogen.LoginResponse.TokenPayload.token_type)
  return token_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse_TokenPayload::release_token_type() {
  // @@protoc_insertion_point(field_release:erogen.LoginResponse.TokenPayload.token_type)
  
  return token_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse_TokenPayload::set_allocated_token_type(::std::string* token_type) {
  if (token_type != nullptr) {
    
  } else {
    
  }
  token_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token_type);
  // @@protoc_insertion_point(field_set_allocated:erogen.LoginResponse.TokenPayload.token_type)
}

// string scope = 5;
inline void LoginResponse_TokenPayload::clear_scope() {
  scope_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginResponse_TokenPayload::scope() const {
  // @@protoc_insertion_point(field_get:erogen.LoginResponse.TokenPayload.scope)
  return scope_.GetNoArena();
}
inline void LoginResponse_TokenPayload::set_scope(const ::std::string& value) {
  
  scope_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.LoginResponse.TokenPayload.scope)
}
#if LANG_CXX11
inline void LoginResponse_TokenPayload::set_scope(::std::string&& value) {
  
  scope_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.LoginResponse.TokenPayload.scope)
}
#endif
inline void LoginResponse_TokenPayload::set_scope(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  scope_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.LoginResponse.TokenPayload.scope)
}
inline void LoginResponse_TokenPayload::set_scope(const char* value, size_t size) {
  
  scope_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.LoginResponse.TokenPayload.scope)
}
inline ::std::string* LoginResponse_TokenPayload::mutable_scope() {
  
  // @@protoc_insertion_point(field_mutable:erogen.LoginResponse.TokenPayload.scope)
  return scope_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse_TokenPayload::release_scope() {
  // @@protoc_insertion_point(field_release:erogen.LoginResponse.TokenPayload.scope)
  
  return scope_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse_TokenPayload::set_allocated_scope(::std::string* scope) {
  if (scope != nullptr) {
    
  } else {
    
  }
  scope_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scope);
  // @@protoc_insertion_point(field_set_allocated:erogen.LoginResponse.TokenPayload.scope)
}

// int32 expires_in = 6;
inline void LoginResponse_TokenPayload::clear_expires_in() {
  expires_in_ = 0;
}
inline ::google::protobuf::int32 LoginResponse_TokenPayload::expires_in() const {
  // @@protoc_insertion_point(field_get:erogen.LoginResponse.TokenPayload.expires_in)
  return expires_in_;
}
inline void LoginResponse_TokenPayload::set_expires_in(::google::protobuf::int32 value) {
  
  expires_in_ = value;
  // @@protoc_insertion_point(field_set:erogen.LoginResponse.TokenPayload.expires_in)
}

// -------------------------------------------------------------------

// LoginResponse

// bool success = 1;
inline void LoginResponse::clear_success() {
  success_ = false;
}
inline bool LoginResponse::success() const {
  // @@protoc_insertion_point(field_get:erogen.LoginResponse.success)
  return success_;
}
inline void LoginResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:erogen.LoginResponse.success)
}

// .erogen.LoginResponse.TokenPayload payload = 2;
inline bool LoginResponse::has_payload() const {
  return this != internal_default_instance() && payload_ != nullptr;
}
inline void LoginResponse::clear_payload() {
  if (GetArenaNoVirtual() == nullptr && payload_ != nullptr) {
    delete payload_;
  }
  payload_ = nullptr;
}
inline const ::erogen::LoginResponse_TokenPayload& LoginResponse::payload() const {
  const ::erogen::LoginResponse_TokenPayload* p = payload_;
  // @@protoc_insertion_point(field_get:erogen.LoginResponse.payload)
  return p != nullptr ? *p : *reinterpret_cast<const ::erogen::LoginResponse_TokenPayload*>(
      &::erogen::_LoginResponse_TokenPayload_default_instance_);
}
inline ::erogen::LoginResponse_TokenPayload* LoginResponse::release_payload() {
  // @@protoc_insertion_point(field_release:erogen.LoginResponse.payload)
  
  ::erogen::LoginResponse_TokenPayload* temp = payload_;
  payload_ = nullptr;
  return temp;
}
inline ::erogen::LoginResponse_TokenPayload* LoginResponse::mutable_payload() {
  
  if (payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::erogen::LoginResponse_TokenPayload>(GetArenaNoVirtual());
    payload_ = p;
  }
  // @@protoc_insertion_point(field_mutable:erogen.LoginResponse.payload)
  return payload_;
}
inline void LoginResponse::set_allocated_payload(::erogen::LoginResponse_TokenPayload* payload) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete payload_;
  }
  if (payload) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      payload = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:erogen.LoginResponse.payload)
}

// -------------------------------------------------------------------

// RegisterRequest

// string username = 1;
inline void RegisterRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterRequest::username() const {
  // @@protoc_insertion_point(field_get:erogen.RegisterRequest.username)
  return username_.GetNoArena();
}
inline void RegisterRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.RegisterRequest.username)
}
#if LANG_CXX11
inline void RegisterRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.RegisterRequest.username)
}
#endif
inline void RegisterRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.RegisterRequest.username)
}
inline void RegisterRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.RegisterRequest.username)
}
inline ::std::string* RegisterRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:erogen.RegisterRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_username() {
  // @@protoc_insertion_point(field_release:erogen.RegisterRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_username(::std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:erogen.RegisterRequest.username)
}

// string email_address = 2;
inline void RegisterRequest::clear_email_address() {
  email_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterRequest::email_address() const {
  // @@protoc_insertion_point(field_get:erogen.RegisterRequest.email_address)
  return email_address_.GetNoArena();
}
inline void RegisterRequest::set_email_address(const ::std::string& value) {
  
  email_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.RegisterRequest.email_address)
}
#if LANG_CXX11
inline void RegisterRequest::set_email_address(::std::string&& value) {
  
  email_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.RegisterRequest.email_address)
}
#endif
inline void RegisterRequest::set_email_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  email_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.RegisterRequest.email_address)
}
inline void RegisterRequest::set_email_address(const char* value, size_t size) {
  
  email_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.RegisterRequest.email_address)
}
inline ::std::string* RegisterRequest::mutable_email_address() {
  
  // @@protoc_insertion_point(field_mutable:erogen.RegisterRequest.email_address)
  return email_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_email_address() {
  // @@protoc_insertion_point(field_release:erogen.RegisterRequest.email_address)
  
  return email_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_email_address(::std::string* email_address) {
  if (email_address != nullptr) {
    
  } else {
    
  }
  email_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email_address);
  // @@protoc_insertion_point(field_set_allocated:erogen.RegisterRequest.email_address)
}

// string password = 3;
inline void RegisterRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterRequest::password() const {
  // @@protoc_insertion_point(field_get:erogen.RegisterRequest.password)
  return password_.GetNoArena();
}
inline void RegisterRequest::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.RegisterRequest.password)
}
#if LANG_CXX11
inline void RegisterRequest::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.RegisterRequest.password)
}
#endif
inline void RegisterRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.RegisterRequest.password)
}
inline void RegisterRequest::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.RegisterRequest.password)
}
inline ::std::string* RegisterRequest::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:erogen.RegisterRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_password() {
  // @@protoc_insertion_point(field_release:erogen.RegisterRequest.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:erogen.RegisterRequest.password)
}

// string accepted_tos_version = 4;
inline void RegisterRequest::clear_accepted_tos_version() {
  accepted_tos_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterRequest::accepted_tos_version() const {
  // @@protoc_insertion_point(field_get:erogen.RegisterRequest.accepted_tos_version)
  return accepted_tos_version_.GetNoArena();
}
inline void RegisterRequest::set_accepted_tos_version(const ::std::string& value) {
  
  accepted_tos_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.RegisterRequest.accepted_tos_version)
}
#if LANG_CXX11
inline void RegisterRequest::set_accepted_tos_version(::std::string&& value) {
  
  accepted_tos_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.RegisterRequest.accepted_tos_version)
}
#endif
inline void RegisterRequest::set_accepted_tos_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  accepted_tos_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.RegisterRequest.accepted_tos_version)
}
inline void RegisterRequest::set_accepted_tos_version(const char* value, size_t size) {
  
  accepted_tos_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.RegisterRequest.accepted_tos_version)
}
inline ::std::string* RegisterRequest::mutable_accepted_tos_version() {
  
  // @@protoc_insertion_point(field_mutable:erogen.RegisterRequest.accepted_tos_version)
  return accepted_tos_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_accepted_tos_version() {
  // @@protoc_insertion_point(field_release:erogen.RegisterRequest.accepted_tos_version)
  
  return accepted_tos_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_accepted_tos_version(::std::string* accepted_tos_version) {
  if (accepted_tos_version != nullptr) {
    
  } else {
    
  }
  accepted_tos_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), accepted_tos_version);
  // @@protoc_insertion_point(field_set_allocated:erogen.RegisterRequest.accepted_tos_version)
}

// -------------------------------------------------------------------

// RegisterResponse

// bool success = 1;
inline void RegisterResponse::clear_success() {
  success_ = false;
}
inline bool RegisterResponse::success() const {
  // @@protoc_insertion_point(field_get:erogen.RegisterResponse.success)
  return success_;
}
inline void RegisterResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:erogen.RegisterResponse.success)
}

// string message = 2;
inline void RegisterResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterResponse::message() const {
  // @@protoc_insertion_point(field_get:erogen.RegisterResponse.message)
  return message_.GetNoArena();
}
inline void RegisterResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.RegisterResponse.message)
}
#if LANG_CXX11
inline void RegisterResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.RegisterResponse.message)
}
#endif
inline void RegisterResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.RegisterResponse.message)
}
inline void RegisterResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.RegisterResponse.message)
}
inline ::std::string* RegisterResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:erogen.RegisterResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterResponse::release_message() {
  // @@protoc_insertion_point(field_release:erogen.RegisterResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterResponse::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:erogen.RegisterResponse.message)
}

// -------------------------------------------------------------------

// ChangeEmailRequest

// string id = 1;
inline void ChangeEmailRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangeEmailRequest::id() const {
  // @@protoc_insertion_point(field_get:erogen.ChangeEmailRequest.id)
  return id_.GetNoArena();
}
inline void ChangeEmailRequest::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ChangeEmailRequest.id)
}
#if LANG_CXX11
inline void ChangeEmailRequest::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ChangeEmailRequest.id)
}
#endif
inline void ChangeEmailRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ChangeEmailRequest.id)
}
inline void ChangeEmailRequest::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ChangeEmailRequest.id)
}
inline ::std::string* ChangeEmailRequest::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ChangeEmailRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeEmailRequest::release_id() {
  // @@protoc_insertion_point(field_release:erogen.ChangeEmailRequest.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeEmailRequest::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:erogen.ChangeEmailRequest.id)
}

// string current_email = 2;
inline void ChangeEmailRequest::clear_current_email() {
  current_email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangeEmailRequest::current_email() const {
  // @@protoc_insertion_point(field_get:erogen.ChangeEmailRequest.current_email)
  return current_email_.GetNoArena();
}
inline void ChangeEmailRequest::set_current_email(const ::std::string& value) {
  
  current_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ChangeEmailRequest.current_email)
}
#if LANG_CXX11
inline void ChangeEmailRequest::set_current_email(::std::string&& value) {
  
  current_email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ChangeEmailRequest.current_email)
}
#endif
inline void ChangeEmailRequest::set_current_email(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  current_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ChangeEmailRequest.current_email)
}
inline void ChangeEmailRequest::set_current_email(const char* value, size_t size) {
  
  current_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ChangeEmailRequest.current_email)
}
inline ::std::string* ChangeEmailRequest::mutable_current_email() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ChangeEmailRequest.current_email)
  return current_email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeEmailRequest::release_current_email() {
  // @@protoc_insertion_point(field_release:erogen.ChangeEmailRequest.current_email)
  
  return current_email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeEmailRequest::set_allocated_current_email(::std::string* current_email) {
  if (current_email != nullptr) {
    
  } else {
    
  }
  current_email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_email);
  // @@protoc_insertion_point(field_set_allocated:erogen.ChangeEmailRequest.current_email)
}

// string new_email = 3;
inline void ChangeEmailRequest::clear_new_email() {
  new_email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangeEmailRequest::new_email() const {
  // @@protoc_insertion_point(field_get:erogen.ChangeEmailRequest.new_email)
  return new_email_.GetNoArena();
}
inline void ChangeEmailRequest::set_new_email(const ::std::string& value) {
  
  new_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ChangeEmailRequest.new_email)
}
#if LANG_CXX11
inline void ChangeEmailRequest::set_new_email(::std::string&& value) {
  
  new_email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ChangeEmailRequest.new_email)
}
#endif
inline void ChangeEmailRequest::set_new_email(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  new_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ChangeEmailRequest.new_email)
}
inline void ChangeEmailRequest::set_new_email(const char* value, size_t size) {
  
  new_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ChangeEmailRequest.new_email)
}
inline ::std::string* ChangeEmailRequest::mutable_new_email() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ChangeEmailRequest.new_email)
  return new_email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeEmailRequest::release_new_email() {
  // @@protoc_insertion_point(field_release:erogen.ChangeEmailRequest.new_email)
  
  return new_email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeEmailRequest::set_allocated_new_email(::std::string* new_email) {
  if (new_email != nullptr) {
    
  } else {
    
  }
  new_email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_email);
  // @@protoc_insertion_point(field_set_allocated:erogen.ChangeEmailRequest.new_email)
}

// -------------------------------------------------------------------

// ChangeEmailResponse

// bool success = 1;
inline void ChangeEmailResponse::clear_success() {
  success_ = false;
}
inline bool ChangeEmailResponse::success() const {
  // @@protoc_insertion_point(field_get:erogen.ChangeEmailResponse.success)
  return success_;
}
inline void ChangeEmailResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:erogen.ChangeEmailResponse.success)
}

// string message = 2;
inline void ChangeEmailResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangeEmailResponse::message() const {
  // @@protoc_insertion_point(field_get:erogen.ChangeEmailResponse.message)
  return message_.GetNoArena();
}
inline void ChangeEmailResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ChangeEmailResponse.message)
}
#if LANG_CXX11
inline void ChangeEmailResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ChangeEmailResponse.message)
}
#endif
inline void ChangeEmailResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ChangeEmailResponse.message)
}
inline void ChangeEmailResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ChangeEmailResponse.message)
}
inline ::std::string* ChangeEmailResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ChangeEmailResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeEmailResponse::release_message() {
  // @@protoc_insertion_point(field_release:erogen.ChangeEmailResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeEmailResponse::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:erogen.ChangeEmailResponse.message)
}

// -------------------------------------------------------------------

// ChangeUsernameRequest

// string id = 1;
inline void ChangeUsernameRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangeUsernameRequest::id() const {
  // @@protoc_insertion_point(field_get:erogen.ChangeUsernameRequest.id)
  return id_.GetNoArena();
}
inline void ChangeUsernameRequest::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ChangeUsernameRequest.id)
}
#if LANG_CXX11
inline void ChangeUsernameRequest::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ChangeUsernameRequest.id)
}
#endif
inline void ChangeUsernameRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ChangeUsernameRequest.id)
}
inline void ChangeUsernameRequest::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ChangeUsernameRequest.id)
}
inline ::std::string* ChangeUsernameRequest::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ChangeUsernameRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeUsernameRequest::release_id() {
  // @@protoc_insertion_point(field_release:erogen.ChangeUsernameRequest.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeUsernameRequest::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:erogen.ChangeUsernameRequest.id)
}

// string current_username = 2;
inline void ChangeUsernameRequest::clear_current_username() {
  current_username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangeUsernameRequest::current_username() const {
  // @@protoc_insertion_point(field_get:erogen.ChangeUsernameRequest.current_username)
  return current_username_.GetNoArena();
}
inline void ChangeUsernameRequest::set_current_username(const ::std::string& value) {
  
  current_username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ChangeUsernameRequest.current_username)
}
#if LANG_CXX11
inline void ChangeUsernameRequest::set_current_username(::std::string&& value) {
  
  current_username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ChangeUsernameRequest.current_username)
}
#endif
inline void ChangeUsernameRequest::set_current_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  current_username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ChangeUsernameRequest.current_username)
}
inline void ChangeUsernameRequest::set_current_username(const char* value, size_t size) {
  
  current_username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ChangeUsernameRequest.current_username)
}
inline ::std::string* ChangeUsernameRequest::mutable_current_username() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ChangeUsernameRequest.current_username)
  return current_username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeUsernameRequest::release_current_username() {
  // @@protoc_insertion_point(field_release:erogen.ChangeUsernameRequest.current_username)
  
  return current_username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeUsernameRequest::set_allocated_current_username(::std::string* current_username) {
  if (current_username != nullptr) {
    
  } else {
    
  }
  current_username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_username);
  // @@protoc_insertion_point(field_set_allocated:erogen.ChangeUsernameRequest.current_username)
}

// string new_username = 3;
inline void ChangeUsernameRequest::clear_new_username() {
  new_username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangeUsernameRequest::new_username() const {
  // @@protoc_insertion_point(field_get:erogen.ChangeUsernameRequest.new_username)
  return new_username_.GetNoArena();
}
inline void ChangeUsernameRequest::set_new_username(const ::std::string& value) {
  
  new_username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ChangeUsernameRequest.new_username)
}
#if LANG_CXX11
inline void ChangeUsernameRequest::set_new_username(::std::string&& value) {
  
  new_username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ChangeUsernameRequest.new_username)
}
#endif
inline void ChangeUsernameRequest::set_new_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  new_username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ChangeUsernameRequest.new_username)
}
inline void ChangeUsernameRequest::set_new_username(const char* value, size_t size) {
  
  new_username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ChangeUsernameRequest.new_username)
}
inline ::std::string* ChangeUsernameRequest::mutable_new_username() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ChangeUsernameRequest.new_username)
  return new_username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeUsernameRequest::release_new_username() {
  // @@protoc_insertion_point(field_release:erogen.ChangeUsernameRequest.new_username)
  
  return new_username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeUsernameRequest::set_allocated_new_username(::std::string* new_username) {
  if (new_username != nullptr) {
    
  } else {
    
  }
  new_username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_username);
  // @@protoc_insertion_point(field_set_allocated:erogen.ChangeUsernameRequest.new_username)
}

// -------------------------------------------------------------------

// ChangeUsernameResponse

// bool success = 1;
inline void ChangeUsernameResponse::clear_success() {
  success_ = false;
}
inline bool ChangeUsernameResponse::success() const {
  // @@protoc_insertion_point(field_get:erogen.ChangeUsernameResponse.success)
  return success_;
}
inline void ChangeUsernameResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:erogen.ChangeUsernameResponse.success)
}

// string message = 2;
inline void ChangeUsernameResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangeUsernameResponse::message() const {
  // @@protoc_insertion_point(field_get:erogen.ChangeUsernameResponse.message)
  return message_.GetNoArena();
}
inline void ChangeUsernameResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ChangeUsernameResponse.message)
}
#if LANG_CXX11
inline void ChangeUsernameResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ChangeUsernameResponse.message)
}
#endif
inline void ChangeUsernameResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ChangeUsernameResponse.message)
}
inline void ChangeUsernameResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ChangeUsernameResponse.message)
}
inline ::std::string* ChangeUsernameResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ChangeUsernameResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeUsernameResponse::release_message() {
  // @@protoc_insertion_point(field_release:erogen.ChangeUsernameResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeUsernameResponse::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:erogen.ChangeUsernameResponse.message)
}

// -------------------------------------------------------------------

// ChangePasswordRequest

// string id = 1;
inline void ChangePasswordRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangePasswordRequest::id() const {
  // @@protoc_insertion_point(field_get:erogen.ChangePasswordRequest.id)
  return id_.GetNoArena();
}
inline void ChangePasswordRequest::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ChangePasswordRequest.id)
}
#if LANG_CXX11
inline void ChangePasswordRequest::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ChangePasswordRequest.id)
}
#endif
inline void ChangePasswordRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ChangePasswordRequest.id)
}
inline void ChangePasswordRequest::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ChangePasswordRequest.id)
}
inline ::std::string* ChangePasswordRequest::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ChangePasswordRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangePasswordRequest::release_id() {
  // @@protoc_insertion_point(field_release:erogen.ChangePasswordRequest.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangePasswordRequest::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:erogen.ChangePasswordRequest.id)
}

// string current_password = 2;
inline void ChangePasswordRequest::clear_current_password() {
  current_password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangePasswordRequest::current_password() const {
  // @@protoc_insertion_point(field_get:erogen.ChangePasswordRequest.current_password)
  return current_password_.GetNoArena();
}
inline void ChangePasswordRequest::set_current_password(const ::std::string& value) {
  
  current_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ChangePasswordRequest.current_password)
}
#if LANG_CXX11
inline void ChangePasswordRequest::set_current_password(::std::string&& value) {
  
  current_password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ChangePasswordRequest.current_password)
}
#endif
inline void ChangePasswordRequest::set_current_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  current_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ChangePasswordRequest.current_password)
}
inline void ChangePasswordRequest::set_current_password(const char* value, size_t size) {
  
  current_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ChangePasswordRequest.current_password)
}
inline ::std::string* ChangePasswordRequest::mutable_current_password() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ChangePasswordRequest.current_password)
  return current_password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangePasswordRequest::release_current_password() {
  // @@protoc_insertion_point(field_release:erogen.ChangePasswordRequest.current_password)
  
  return current_password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangePasswordRequest::set_allocated_current_password(::std::string* current_password) {
  if (current_password != nullptr) {
    
  } else {
    
  }
  current_password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_password);
  // @@protoc_insertion_point(field_set_allocated:erogen.ChangePasswordRequest.current_password)
}

// string new_password = 3;
inline void ChangePasswordRequest::clear_new_password() {
  new_password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangePasswordRequest::new_password() const {
  // @@protoc_insertion_point(field_get:erogen.ChangePasswordRequest.new_password)
  return new_password_.GetNoArena();
}
inline void ChangePasswordRequest::set_new_password(const ::std::string& value) {
  
  new_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ChangePasswordRequest.new_password)
}
#if LANG_CXX11
inline void ChangePasswordRequest::set_new_password(::std::string&& value) {
  
  new_password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ChangePasswordRequest.new_password)
}
#endif
inline void ChangePasswordRequest::set_new_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  new_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ChangePasswordRequest.new_password)
}
inline void ChangePasswordRequest::set_new_password(const char* value, size_t size) {
  
  new_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ChangePasswordRequest.new_password)
}
inline ::std::string* ChangePasswordRequest::mutable_new_password() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ChangePasswordRequest.new_password)
  return new_password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangePasswordRequest::release_new_password() {
  // @@protoc_insertion_point(field_release:erogen.ChangePasswordRequest.new_password)
  
  return new_password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangePasswordRequest::set_allocated_new_password(::std::string* new_password) {
  if (new_password != nullptr) {
    
  } else {
    
  }
  new_password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_password);
  // @@protoc_insertion_point(field_set_allocated:erogen.ChangePasswordRequest.new_password)
}

// -------------------------------------------------------------------

// ChangePasswordResponse

// bool success = 1;
inline void ChangePasswordResponse::clear_success() {
  success_ = false;
}
inline bool ChangePasswordResponse::success() const {
  // @@protoc_insertion_point(field_get:erogen.ChangePasswordResponse.success)
  return success_;
}
inline void ChangePasswordResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:erogen.ChangePasswordResponse.success)
}

// string message = 2;
inline void ChangePasswordResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChangePasswordResponse::message() const {
  // @@protoc_insertion_point(field_get:erogen.ChangePasswordResponse.message)
  return message_.GetNoArena();
}
inline void ChangePasswordResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ChangePasswordResponse.message)
}
#if LANG_CXX11
inline void ChangePasswordResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ChangePasswordResponse.message)
}
#endif
inline void ChangePasswordResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ChangePasswordResponse.message)
}
inline void ChangePasswordResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ChangePasswordResponse.message)
}
inline ::std::string* ChangePasswordResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ChangePasswordResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangePasswordResponse::release_message() {
  // @@protoc_insertion_point(field_release:erogen.ChangePasswordResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangePasswordResponse::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:erogen.ChangePasswordResponse.message)
}

// -------------------------------------------------------------------

// ForgotPasswordRequest

// string email_address = 1;
inline void ForgotPasswordRequest::clear_email_address() {
  email_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ForgotPasswordRequest::email_address() const {
  // @@protoc_insertion_point(field_get:erogen.ForgotPasswordRequest.email_address)
  return email_address_.GetNoArena();
}
inline void ForgotPasswordRequest::set_email_address(const ::std::string& value) {
  
  email_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ForgotPasswordRequest.email_address)
}
#if LANG_CXX11
inline void ForgotPasswordRequest::set_email_address(::std::string&& value) {
  
  email_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ForgotPasswordRequest.email_address)
}
#endif
inline void ForgotPasswordRequest::set_email_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  email_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ForgotPasswordRequest.email_address)
}
inline void ForgotPasswordRequest::set_email_address(const char* value, size_t size) {
  
  email_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ForgotPasswordRequest.email_address)
}
inline ::std::string* ForgotPasswordRequest::mutable_email_address() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ForgotPasswordRequest.email_address)
  return email_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ForgotPasswordRequest::release_email_address() {
  // @@protoc_insertion_point(field_release:erogen.ForgotPasswordRequest.email_address)
  
  return email_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ForgotPasswordRequest::set_allocated_email_address(::std::string* email_address) {
  if (email_address != nullptr) {
    
  } else {
    
  }
  email_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email_address);
  // @@protoc_insertion_point(field_set_allocated:erogen.ForgotPasswordRequest.email_address)
}

// -------------------------------------------------------------------

// ForgotPasswordResponse

// bool user_exists = 1;
inline void ForgotPasswordResponse::clear_user_exists() {
  user_exists_ = false;
}
inline bool ForgotPasswordResponse::user_exists() const {
  // @@protoc_insertion_point(field_get:erogen.ForgotPasswordResponse.user_exists)
  return user_exists_;
}
inline void ForgotPasswordResponse::set_user_exists(bool value) {
  
  user_exists_ = value;
  // @@protoc_insertion_point(field_set:erogen.ForgotPasswordResponse.user_exists)
}

// bool sendemail_queued = 2;
inline void ForgotPasswordResponse::clear_sendemail_queued() {
  sendemail_queued_ = false;
}
inline bool ForgotPasswordResponse::sendemail_queued() const {
  // @@protoc_insertion_point(field_get:erogen.ForgotPasswordResponse.sendemail_queued)
  return sendemail_queued_;
}
inline void ForgotPasswordResponse::set_sendemail_queued(bool value) {
  
  sendemail_queued_ = value;
  // @@protoc_insertion_point(field_set:erogen.ForgotPasswordResponse.sendemail_queued)
}

// -------------------------------------------------------------------

// ResetPasswordRequest

// string user_id = 1;
inline void ResetPasswordRequest::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResetPasswordRequest::user_id() const {
  // @@protoc_insertion_point(field_get:erogen.ResetPasswordRequest.user_id)
  return user_id_.GetNoArena();
}
inline void ResetPasswordRequest::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ResetPasswordRequest.user_id)
}
#if LANG_CXX11
inline void ResetPasswordRequest::set_user_id(::std::string&& value) {
  
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ResetPasswordRequest.user_id)
}
#endif
inline void ResetPasswordRequest::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ResetPasswordRequest.user_id)
}
inline void ResetPasswordRequest::set_user_id(const char* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ResetPasswordRequest.user_id)
}
inline ::std::string* ResetPasswordRequest::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ResetPasswordRequest.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResetPasswordRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:erogen.ResetPasswordRequest.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResetPasswordRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:erogen.ResetPasswordRequest.user_id)
}

// string new_password = 2;
inline void ResetPasswordRequest::clear_new_password() {
  new_password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResetPasswordRequest::new_password() const {
  // @@protoc_insertion_point(field_get:erogen.ResetPasswordRequest.new_password)
  return new_password_.GetNoArena();
}
inline void ResetPasswordRequest::set_new_password(const ::std::string& value) {
  
  new_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ResetPasswordRequest.new_password)
}
#if LANG_CXX11
inline void ResetPasswordRequest::set_new_password(::std::string&& value) {
  
  new_password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ResetPasswordRequest.new_password)
}
#endif
inline void ResetPasswordRequest::set_new_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  new_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ResetPasswordRequest.new_password)
}
inline void ResetPasswordRequest::set_new_password(const char* value, size_t size) {
  
  new_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ResetPasswordRequest.new_password)
}
inline ::std::string* ResetPasswordRequest::mutable_new_password() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ResetPasswordRequest.new_password)
  return new_password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResetPasswordRequest::release_new_password() {
  // @@protoc_insertion_point(field_release:erogen.ResetPasswordRequest.new_password)
  
  return new_password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResetPasswordRequest::set_allocated_new_password(::std::string* new_password) {
  if (new_password != nullptr) {
    
  } else {
    
  }
  new_password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_password);
  // @@protoc_insertion_point(field_set_allocated:erogen.ResetPasswordRequest.new_password)
}

// -------------------------------------------------------------------

// ResetPasswordResponse

// bool success = 1;
inline void ResetPasswordResponse::clear_success() {
  success_ = false;
}
inline bool ResetPasswordResponse::success() const {
  // @@protoc_insertion_point(field_get:erogen.ResetPasswordResponse.success)
  return success_;
}
inline void ResetPasswordResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:erogen.ResetPasswordResponse.success)
}

// string message = 2;
inline void ResetPasswordResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResetPasswordResponse::message() const {
  // @@protoc_insertion_point(field_get:erogen.ResetPasswordResponse.message)
  return message_.GetNoArena();
}
inline void ResetPasswordResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ResetPasswordResponse.message)
}
#if LANG_CXX11
inline void ResetPasswordResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ResetPasswordResponse.message)
}
#endif
inline void ResetPasswordResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ResetPasswordResponse.message)
}
inline void ResetPasswordResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ResetPasswordResponse.message)
}
inline ::std::string* ResetPasswordResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ResetPasswordResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResetPasswordResponse::release_message() {
  // @@protoc_insertion_point(field_release:erogen.ResetPasswordResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResetPasswordResponse::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:erogen.ResetPasswordResponse.message)
}

// -------------------------------------------------------------------

// ValidateTokenRequest

// string token = 1;
inline void ValidateTokenRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ValidateTokenRequest::token() const {
  // @@protoc_insertion_point(field_get:erogen.ValidateTokenRequest.token)
  return token_.GetNoArena();
}
inline void ValidateTokenRequest::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.ValidateTokenRequest.token)
}
#if LANG_CXX11
inline void ValidateTokenRequest::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.ValidateTokenRequest.token)
}
#endif
inline void ValidateTokenRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.ValidateTokenRequest.token)
}
inline void ValidateTokenRequest::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.ValidateTokenRequest.token)
}
inline ::std::string* ValidateTokenRequest::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:erogen.ValidateTokenRequest.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ValidateTokenRequest::release_token() {
  // @@protoc_insertion_point(field_release:erogen.ValidateTokenRequest.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ValidateTokenRequest::set_allocated_token(::std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:erogen.ValidateTokenRequest.token)
}

// .erogen.ValidateTokenRequest.Scope scope = 2;
inline void ValidateTokenRequest::clear_scope() {
  scope_ = 0;
}
inline ::erogen::ValidateTokenRequest_Scope ValidateTokenRequest::scope() const {
  // @@protoc_insertion_point(field_get:erogen.ValidateTokenRequest.scope)
  return static_cast< ::erogen::ValidateTokenRequest_Scope >(scope_);
}
inline void ValidateTokenRequest::set_scope(::erogen::ValidateTokenRequest_Scope value) {
  
  scope_ = value;
  // @@protoc_insertion_point(field_set:erogen.ValidateTokenRequest.scope)
}

// -------------------------------------------------------------------

// ValidateTokenResponse

// bool success = 1;
inline void ValidateTokenResponse::clear_success() {
  success_ = false;
}
inline bool ValidateTokenResponse::success() const {
  // @@protoc_insertion_point(field_get:erogen.ValidateTokenResponse.success)
  return success_;
}
inline void ValidateTokenResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:erogen.ValidateTokenResponse.success)
}

// -------------------------------------------------------------------

// VerifySecurityQARequest

// string answer = 1;
inline void VerifySecurityQARequest::clear_answer() {
  answer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VerifySecurityQARequest::answer() const {
  // @@protoc_insertion_point(field_get:erogen.VerifySecurityQARequest.answer)
  return answer_.GetNoArena();
}
inline void VerifySecurityQARequest::set_answer(const ::std::string& value) {
  
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.VerifySecurityQARequest.answer)
}
#if LANG_CXX11
inline void VerifySecurityQARequest::set_answer(::std::string&& value) {
  
  answer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.VerifySecurityQARequest.answer)
}
#endif
inline void VerifySecurityQARequest::set_answer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.VerifySecurityQARequest.answer)
}
inline void VerifySecurityQARequest::set_answer(const char* value, size_t size) {
  
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.VerifySecurityQARequest.answer)
}
inline ::std::string* VerifySecurityQARequest::mutable_answer() {
  
  // @@protoc_insertion_point(field_mutable:erogen.VerifySecurityQARequest.answer)
  return answer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifySecurityQARequest::release_answer() {
  // @@protoc_insertion_point(field_release:erogen.VerifySecurityQARequest.answer)
  
  return answer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifySecurityQARequest::set_allocated_answer(::std::string* answer) {
  if (answer != nullptr) {
    
  } else {
    
  }
  answer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), answer);
  // @@protoc_insertion_point(field_set_allocated:erogen.VerifySecurityQARequest.answer)
}

// -------------------------------------------------------------------

// VerifySecurityQAResponse

// bool success = 1;
inline void VerifySecurityQAResponse::clear_success() {
  success_ = false;
}
inline bool VerifySecurityQAResponse::success() const {
  // @@protoc_insertion_point(field_get:erogen.VerifySecurityQAResponse.success)
  return success_;
}
inline void VerifySecurityQAResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:erogen.VerifySecurityQAResponse.success)
}

// -------------------------------------------------------------------

// UpdateRequest

// .erogen.User user = 1;
inline bool UpdateRequest::has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline void UpdateRequest::clear_user() {
  if (GetArenaNoVirtual() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::erogen::User& UpdateRequest::user() const {
  const ::erogen::User* p = user_;
  // @@protoc_insertion_point(field_get:erogen.UpdateRequest.user)
  return p != nullptr ? *p : *reinterpret_cast<const ::erogen::User*>(
      &::erogen::_User_default_instance_);
}
inline ::erogen::User* UpdateRequest::release_user() {
  // @@protoc_insertion_point(field_release:erogen.UpdateRequest.user)
  
  ::erogen::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::erogen::User* UpdateRequest::mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::erogen::User>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:erogen.UpdateRequest.user)
  return user_;
}
inline void UpdateRequest::set_allocated_user(::erogen::User* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:erogen.UpdateRequest.user)
}

// -------------------------------------------------------------------

// UpdateResponse

// bool success = 1;
inline void UpdateResponse::clear_success() {
  success_ = false;
}
inline bool UpdateResponse::success() const {
  // @@protoc_insertion_point(field_get:erogen.UpdateResponse.success)
  return success_;
}
inline void UpdateResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:erogen.UpdateResponse.success)
}

// .erogen.User user = 2;
inline bool UpdateResponse::has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline void UpdateResponse::clear_user() {
  if (GetArenaNoVirtual() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::erogen::User& UpdateResponse::user() const {
  const ::erogen::User* p = user_;
  // @@protoc_insertion_point(field_get:erogen.UpdateResponse.user)
  return p != nullptr ? *p : *reinterpret_cast<const ::erogen::User*>(
      &::erogen::_User_default_instance_);
}
inline ::erogen::User* UpdateResponse::release_user() {
  // @@protoc_insertion_point(field_release:erogen.UpdateResponse.user)
  
  ::erogen::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::erogen::User* UpdateResponse::mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::erogen::User>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:erogen.UpdateResponse.user)
  return user_;
}
inline void UpdateResponse::set_allocated_user(::erogen::User* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:erogen.UpdateResponse.user)
}

// -------------------------------------------------------------------

// DeleteRequest

// string id = 1;
inline void DeleteRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteRequest::id() const {
  // @@protoc_insertion_point(field_get:erogen.DeleteRequest.id)
  return id_.GetNoArena();
}
inline void DeleteRequest::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.DeleteRequest.id)
}
#if LANG_CXX11
inline void DeleteRequest::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.DeleteRequest.id)
}
#endif
inline void DeleteRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.DeleteRequest.id)
}
inline void DeleteRequest::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.DeleteRequest.id)
}
inline ::std::string* DeleteRequest::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:erogen.DeleteRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRequest::release_id() {
  // @@protoc_insertion_point(field_release:erogen.DeleteRequest.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRequest::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:erogen.DeleteRequest.id)
}

// -------------------------------------------------------------------

// DeleteResponse

// bool success = 1;
inline void DeleteResponse::clear_success() {
  success_ = false;
}
inline bool DeleteResponse::success() const {
  // @@protoc_insertion_point(field_get:erogen.DeleteResponse.success)
  return success_;
}
inline void DeleteResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:erogen.DeleteResponse.success)
}

// -------------------------------------------------------------------

// UserRequest

// string id = 1;
inline void UserRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserRequest::id() const {
  // @@protoc_insertion_point(field_get:erogen.UserRequest.id)
  return id_.GetNoArena();
}
inline void UserRequest::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.UserRequest.id)
}
#if LANG_CXX11
inline void UserRequest::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.UserRequest.id)
}
#endif
inline void UserRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.UserRequest.id)
}
inline void UserRequest::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.UserRequest.id)
}
inline ::std::string* UserRequest::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:erogen.UserRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRequest::release_id() {
  // @@protoc_insertion_point(field_release:erogen.UserRequest.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRequest::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:erogen.UserRequest.id)
}

// -------------------------------------------------------------------

// UserResponse

// .erogen.User user = 1;
inline bool UserResponse::has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline void UserResponse::clear_user() {
  if (GetArenaNoVirtual() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::erogen::User& UserResponse::user() const {
  const ::erogen::User* p = user_;
  // @@protoc_insertion_point(field_get:erogen.UserResponse.user)
  return p != nullptr ? *p : *reinterpret_cast<const ::erogen::User*>(
      &::erogen::_User_default_instance_);
}
inline ::erogen::User* UserResponse::release_user() {
  // @@protoc_insertion_point(field_release:erogen.UserResponse.user)
  
  ::erogen::User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::erogen::User* UserResponse::mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::erogen::User>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:erogen.UserResponse.user)
  return user_;
}
inline void UserResponse::set_allocated_user(::erogen::User* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:erogen.UserResponse.user)
}

// -------------------------------------------------------------------

// UsersRequest

// string filter = 1;
inline void UsersRequest::clear_filter() {
  filter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UsersRequest::filter() const {
  // @@protoc_insertion_point(field_get:erogen.UsersRequest.filter)
  return filter_.GetNoArena();
}
inline void UsersRequest::set_filter(const ::std::string& value) {
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:erogen.UsersRequest.filter)
}
#if LANG_CXX11
inline void UsersRequest::set_filter(::std::string&& value) {
  
  filter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:erogen.UsersRequest.filter)
}
#endif
inline void UsersRequest::set_filter(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:erogen.UsersRequest.filter)
}
inline void UsersRequest::set_filter(const char* value, size_t size) {
  
  filter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:erogen.UsersRequest.filter)
}
inline ::std::string* UsersRequest::mutable_filter() {
  
  // @@protoc_insertion_point(field_mutable:erogen.UsersRequest.filter)
  return filter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UsersRequest::release_filter() {
  // @@protoc_insertion_point(field_release:erogen.UsersRequest.filter)
  
  return filter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UsersRequest::set_allocated_filter(::std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  filter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filter);
  // @@protoc_insertion_point(field_set_allocated:erogen.UsersRequest.filter)
}

// uint32 count = 2;
inline void UsersRequest::clear_count() {
  count_ = 0u;
}
inline ::google::protobuf::uint32 UsersRequest::count() const {
  // @@protoc_insertion_point(field_get:erogen.UsersRequest.count)
  return count_;
}
inline void UsersRequest::set_count(::google::protobuf::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:erogen.UsersRequest.count)
}

// uint32 offset = 3;
inline void UsersRequest::clear_offset() {
  offset_ = 0u;
}
inline ::google::protobuf::uint32 UsersRequest::offset() const {
  // @@protoc_insertion_point(field_get:erogen.UsersRequest.offset)
  return offset_;
}
inline void UsersRequest::set_offset(::google::protobuf::uint32 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:erogen.UsersRequest.offset)
}

// -------------------------------------------------------------------

// User

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace erogen

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::erogen::ValidateTokenRequest_Scope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::erogen::ValidateTokenRequest_Scope>() {
  return ::erogen::ValidateTokenRequest_Scope_descriptor();
}
template <> struct is_proto_enum< ::erogen::UserIdentifierType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::erogen::UserIdentifierType>() {
  return ::erogen::UserIdentifierType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_proto_2fuser_2fuser_2eproto
